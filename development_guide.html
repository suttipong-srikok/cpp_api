<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ REST API Development Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        code {
            background-color: #e8e8e8;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            background-color: #2d2d2d;
            color: #f1f1f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        .file-block {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .file-header {
            background-color: #f0f0f0;
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
        }
        .file-content {
            padding: 15px;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>

    <h1>Complete Development Guide: C++ REST API with SQLite, Redis, spdlog, and JWT</h1>

    <p>This guide provides a comprehensive walkthrough for building a simple, yet fully functional, C++ RESTful API from the ground up. We'll be using the <a href="https://github.com/CrowCpp/Crow" target="_blank">Crow C++ micro-framework</a>, a SQLite database for persistence, Redis for caching and messaging, spdlog for structured logging, and jwt-cpp for JWT-based authentication, and containerizing the entire application with Docker.</p>

    <h2>1. Prerequisites</h2>
    <p>Before you begin, ensure you have the following tools installed on your system:</p>
    <ul>
        <li><a href="https://docs.docker.com/get-docker/" target="_blank">Docker</a>: For containerizing our application.</li>
        <li><a href="https://docs.docker.com/compose/install/" target="_blank">Docker Compose</a>: For simplifying multi-container Docker applications.</li>
    </ul>

    <h2>2. Project Structure</h2>
    <p>First, let's create our project directory and the necessary files. The final structure will look like this:</p>
    <pre><code>
. 
├── docker-compose.yml
├── Dockerfile
├── .gitignore
└── src/ 
    └── main.cpp
    </code></pre>

    <h2>3. Creating the Project Files</h2>

    <p>Let's create each file one by one.</p>

    <div class="file-block">
        <div class="file-header"><code>.gitignore</code></div>
        <div class="file-content">
            <p>Create a <code>.gitignore</code> file to prevent build artifacts and other unnecessary files from being committed to version control.</p>
            <pre><code>
# Build artifacts
build/
*.o
*.out
api

# Docker
.dockerignore
docker-compose.override.yml

# Logs
logs/

# Database
database/
            </code></pre>
        </div>
    </div>

    <div class="file-block">
        <div class="file-header"><code>src/main.cpp</code></div>
        <div class="file-content">
            <p>This is the heart of our application. It contains the C++ code for our API server, including the SQLite, Redis, spdlog, and JWT integration.</p>
            <pre><code class="language-cpp">
// src/main.cpp

#include "Crow/include/crow.h"
#include &lt;hiredis/hiredis.h&gt;
#include &lt;sqlite3.h&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include "spdlog/spdlog.h"
#include "spdlog/sinks/basic_file_sink.h"
#include "jwt-cpp/jwt.h"
#include &lt;sodium.h&gt;

// Define a struct to hold our user data
struct User {
    int id;
    std::string name;
    std::string email;
    std::string password;
};

// Helper function to convert a User struct to a crow::json::wvalue
crow::json::wvalue user_to_json(const User& user) {
    crow::json::wvalue json_user;
    json_user["id"] = user.id;
    json_user["name"] = user.name;
    json_user["email"] = user.email;
    return json_user;
}

// RAII wrapper for redisContext
std::unique_ptr&lt;redisContext, decltype(&redisFree)&gt; new_redis_context() {
    const char* redis_host = std::getenv("REDIS_HOST");
    if (!redis_host) {
        redis_host = "127.0.0.1";
    }
    return std::unique_ptr&lt;redisContext, decltype(&redisFree)&gt;(
        redisConnect(redis_host, 6379),
        redisFree
    );
}

// RAII wrapper for sqlite3
std::unique_ptr&lt;sqlite3, decltype(&sqlite3_close)&gt; new_sqlite_connection() {
    sqlite3* db;
    if (sqlite3_open("database/users.db", &db)) {
        return std::unique_ptr&lt;sqlite3, decltype(&sqlite3_close)&gt;(nullptr, &sqlite3_close);
    }
    return std::unique_ptr&lt;sqlite3, decltype(&sqlite3_close)&gt;(
        db,
        sqlite3_close
    );
}

// Middleware for JWT authentication
struct JwtMiddleware {
    std::string jwt_secret;

    JwtMiddleware() {
        const char* secret = std::getenv("JWT_SECRET");
        if (secret) {
            jwt_secret = secret;
        }
    }

    struct context {};

    void before_handle(crow::request& req, crow::response& res, context& ctx) {
        auto auth_header = req.get_header_value("Authorization");
        if (auth_header.empty() || auth_header.rfind("Bearer ", 0) != 0) {
            res.code = 401;
            res.end("{\"message\": \"Unauthorized\"}");
            return;
        }

        std::string token_str = auth_header.substr(7);

        try {
            auto decoded = jwt::decode(token_str);
            auto verifier = jwt::verify().allow_algorithm(jwt::algorithm::hs256{jwt_secret});
            verifier.verify(decoded);
        } catch (const std::exception& e) {
            res.code = 401;
            res.end("{\"message\": \"Invalid token\"}");
            return;
        }
    }

    void after_handle(crow::request& req, crow::response& res, context& ctx) {}
};

int main()
{
    if (sodium_init() < 0) {
        spdlog::error("Failed to initialize libsodium");
        return 1;
    }

    // Initialize the logger
    auto file_logger = spdlog::basic_logger_mt("basic_logger", "logs/logs.txt");
    spdlog::set_default_logger(file_logger);
    spdlog::set_level(spdlog::level::info);

    // Create a table for users if it doesn't exist
    auto db = new_sqlite_connection();
    if (db) {
        char* err_msg = 0;
        const char* sql = "CREATE TABLE IF NOT EXISTS users(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, email TEXT NOT NULL UNIQUE, password TEXT NOT NULL);";
        int rc = sqlite3_exec(db.get(), sql, 0, 0, &err_msg);
        if (rc != SQLITE_OK) {
            spdlog::error("Failed to create table: {}", err_msg);
            sqlite3_free(err_msg);
        }
    } else {
        spdlog::error("Failed to open database");
    }

    crow::App&lt;JwtMiddleware&gt; app;

    // --- AUTHENTICATION ---
    CROW_ROUTE(app, "/register").methods("POST"_method)
    ([](const crow::request& req){
        auto body = crow::json::load(req.body);
        if (!body || !body.has("name") || !body.has("email") || !body.has("password")) {
            spdlog::warn("Invalid registration request: {}", req.body);
            return crow::response(400, "{\"message\": \"Invalid JSON or missing fields\"}");
        }

        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        std::string name = std::string(body["name"].s());
        std::string email = std::string(body["email"].s());
        std::string password = std::string(body["password"].s());

        // Hash the password
        char hashed_password[crypto_pwhash_STRBYTES];
        if (crypto_pwhash_str(hashed_password, password.c_str(), password.length(), crypto_pwhash_OPSLIMIT_INTERACTIVE, crypto_pwhash_MEMLIMIT_INTERACTIVE) != 0) {
            spdlog::error("Failed to hash password");
            return crow::response(500, "{\"message\": \"Failed to hash password\"}");
        }

        sqlite3_stmt* stmt;
        const char* sql = "INSERT INTO users (name, email, password) VALUES (?, ?, ?);";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);
        sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, email.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 3, hashed_password, -1, SQLITE_STATIC);

        if (sqlite3_step(stmt) != SQLITE_DONE) {
            spdlog::error("Failed to create user: {}", sqlite3_errmsg(db.get()));
            sqlite3_finalize(stmt);
            return crow::response(500, "{\"message\": \"Failed to create user\"}");
        }

        int new_id = sqlite3_last_insert_rowid(db.get());
        sqlite3_finalize(stmt);

        User new_user{new_id, name, email, ""};
        spdlog::info("Created user: id={}, name={}, email={}", new_user.id, new_user.name, new_user.email);

        return crow::response(201, user_to_json(new_user));
    });

    CROW_ROUTE(app, "/login").methods("POST"_method)
    ([&](const crow::request& req){
        auto body = crow::json::load(req.body);
        if (!body || !body.has("email") || !body.has("password")) {
            spdlog::warn("Invalid login request: {}", req.body);
            return crow::response(400, "{\"message\": \"Invalid JSON or missing fields\"}");
        }

        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        std::string email = std::string(body["email"].s());
        std::string password = std::string(body["password"].s());

        sqlite3_stmt* stmt;
        const char* sql = "SELECT id, name, password FROM users WHERE email = ?;";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);
        sqlite3_bind_text(stmt, 1, email.c_str(), -1, SQLITE_STATIC);

        if (sqlite3_step(stmt) != SQLITE_ROW) {
            spdlog::warn("User not found for login: {}", email);
            sqlite3_finalize(stmt);
            return crow::response(401, "{\"message\": \"Invalid credentials\"}");
        }

        int user_id = sqlite3_column_int(stmt, 0);
        std::string user_name = (const char*)sqlite3_column_text(stmt, 1);
        const char* hash = (const char*)sqlite3_column_text(stmt, 2);

        if (crypto_pwhash_str_verify(hash, password.c_str(), password.length()) != 0) {
            spdlog::warn("Invalid password for user: {}", email);
            sqlite3_finalize(stmt);
            return crow::response(401, "{\"message\": \"Invalid credentials\"}");
        }

        sqlite3_finalize(stmt);

        // Create JWT
        auto token = jwt::create()
            .set_issuer("auth0")
            .set_type("JWS")
            .set_payload_claim("user_id", jwt::claim(std::to_string(user_id)))
            .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{3600})
            .sign(jwt::algorithm::hs256{app.get_middleware&lt;JwtMiddleware&gt;().jwt_secret});

        crow::json::wvalue res_body;
        res_body["token"] = token;
        return crow::response(200, res_body);
    });

    // --- PROTECTED ROUTES ---
    CROW_ROUTE(app, "/users").methods("GET"_method)
    .CROW_MIDDLEWARES(app, JwtMiddleware)
    ([](){
        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        sqlite3_stmt* stmt;
        const char* sql = "SELECT id, name, email FROM users;";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);

        std::vector&lt;crow::json::wvalue&gt; json_users;
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            User user;
            user.id = sqlite3_column_int(stmt, 0);
            user.name = (const char*)sqlite3_column_text(stmt, 1);
            user.email = (const char*)sqlite3_column_text(stmt, 2);
            json_users.push_back(user_to_json(user));
        }
        sqlite3_finalize(stmt);

        spdlog::info("Retrieved {} users", json_users.size());
        return crow::response(200, crow::json::wvalue(json_users));
    });

    CROW_ROUTE(app, "/users/<int>").methods("GET"_method)
    .CROW_MIDDLEWARES(app, JwtMiddleware)
    ([](int user_id){
        // Try to get user from Redis cache first
        auto redis = new_redis_context();
        if (redis && !redis->err) {
            auto reply = (redisReply*)redisCommand(redis.get(), "GET user:%d", user_id);
            if (reply->type == REDIS_REPLY_STRING) {
                std::string user_json = reply->str;
                freeReplyObject(reply);
                spdlog::info("Retrieved user {} from cache", user_id);
                return crow::response(200, user_json);
            }
            freeReplyObject(reply);
        }

        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        sqlite3_stmt* stmt;
        const char* sql = "SELECT id, name, email FROM users WHERE id = ?;";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);
        sqlite3_bind_int(stmt, 1, user_id);

        if (sqlite3_step(stmt) != SQLITE_ROW) {
            spdlog::warn("User {} not found", user_id);
            sqlite3_finalize(stmt);
            return crow::response(404, "{\"message\": \"User not found\"}");
        }

        User user;
        user.id = sqlite3_column_int(stmt, 0);
        user.name = (const char*)sqlite3_column_text(stmt, 1);
        user.email = (const char*)sqlite3_column_text(stmt, 2);
        sqlite3_finalize(stmt);

        spdlog::info("Retrieved user {}: name={}, email={}", user.id, user.name, user.email);

        // Cache the user in Redis
        if (redis && !redis->err) {
            std::string user_json = user_to_json(user).dump();
            redisCommand(redis.get(), "SETEX user:%d 3600 %s", user_id, user_json.c_str());
        }

        return crow::response(200, user_to_json(user));
    });

    CROW_ROUTE(app, "/users/<int>").methods("PUT"_method)
    .CROW_MIDDLEWARES(app, JwtMiddleware)
    ([](const crow::request& req, int user_id){
        auto body = crow::json::load(req.body);
        if (!body) {
            spdlog::warn("Invalid user update request: {}", req.body);
            return crow::response(400, "{\"message\": \"Invalid JSON\"}");
        }

        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        std::string name = body.has("name") ? std::string(body["name"].s()) : "";
        std::string email = body.has("email") ? std::string(body["email"].s()) : "";

        sqlite3_stmt* stmt;
        const char* sql = "UPDATE users SET name = ?, email = ? WHERE id = ?;";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);
        sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, email.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_int(stmt, 3, user_id);

        if (sqlite3_step(stmt) != SQLITE_DONE) {
            spdlog::error("Failed to update user {}: {}", user_id, sqlite3_errmsg(db.get()));
            sqlite3_finalize(stmt);
            return crow::response(500, "{\"message\": \"Failed to update user\"}");
        }

        if (sqlite3_changes(db.get()) == 0) {
            spdlog::warn("User {} not found for update", user_id);
            sqlite3_finalize(stmt);
            return crow::response(404, "{\"message\": \"User not found\"}");
        }

        sqlite3_finalize(stmt);
        spdlog::info("Updated user {}", user_id);

        // Invalidate cache
        auto redis = new_redis_context();
        if (redis && !redis->err) {
            redisCommand(redis.get(), "DEL user:%d", user_id);
        }

        return crow::response(200, "{\"message\": \"User updated\"}");
    });

    CROW_ROUTE(app, "/users/<int>").methods("DELETE"_method)
    .CROW_MIDDLEWARES(app, JwtMiddleware)
    ([](int user_id){
        auto db = new_sqlite_connection();
        if (!db) {
            spdlog::error("Failed to connect to SQLite");
            return crow::response(500, "{\"message\": \"Failed to connect to SQLite\"}");
        }

        sqlite3_stmt* stmt;
        const char* sql = "DELETE FROM users WHERE id = ?;";
        sqlite3_prepare_v2(db.get(), sql, -1, &stmt, 0);
        sqlite3_bind_int(stmt, 1, user_id);

        if (sqlite3_step(stmt) != SQLITE_DONE) {
            spdlog::error("Failed to delete user {}: {}", user_id, sqlite3_errmsg(db.get()));
            sqlite3_finalize(stmt);
            return crow::response(500, "{\"message\": \"Failed to delete user\"}");
        }

        if (sqlite3_changes(db.get()) == 0) {
            spdlog::warn("User {} not found for deletion", user_id);
            sqlite3_finalize(stmt);
            return crow::response(404, "{\"message\": \"User not found\"}");
        }

        sqlite3_finalize(stmt);
        spdlog::info("Deleted user {}", user_id);

        // Invalidate cache
        auto redis = new_redis_context();
        if (redis && !redis->err) {
            redisCommand(redis.get(), "DEL user:%d", user_id);
        }

        return crow::response(200, "{\"message\": \"User deleted\"}");
    });

    // --- MESSAGE QUEUE: Add a message (POST /messages) ---
    CROW_ROUTE(app, "/messages").methods("POST"_method)
    ([](const crow::request& req){
        auto body = crow::json::load(req.body);
        if (!body || !body.has("message")) {
            spdlog::warn("Invalid message creation request: {}", req.body);
            return crow::response(400, "{\"message\": \"Invalid JSON or missing message field\"}");
        }

        auto redis = new_redis_context();
        if (!redis || redis->err) {
            spdlog::error("Failed to connect to Redis");
            return crow::response(500, "{\"message\": \"Failed to connect to Redis\"}");
        }

        std::string message = std::string(body["message"].s());
        auto reply = (redisReply*)redisCommand(redis.get(), "LPUSH message_queue %s", message.c_str());
        freeReplyObject(reply);

        spdlog::info("Queued message: {}", message);
        return crow::response(200, "{\"message\": \"Message queued\"}");
    });

    // --- MESSAGE QUEUE: Get a message (GET /messages) ---
    CROW_ROUTE(app, "/messages").methods("GET"_method)
    ([](){
        auto redis = new_redis_context();
        if (!redis || redis->err) {
            spdlog::error("Failed to connect to Redis");
            return crow::response(500, "{\"message\": \"Failed to connect to Redis\"}");
        }

        auto reply = (redisReply*)redisCommand(redis.get(), "RPOP message_queue");
        if (reply->type == REDIS_REPLY_STRING) {
            std::string message = reply->str;
            freeReplyObject(reply);
            spdlog::info("Retrieved message: {}", message);
            return crow::response(200, "{\"message\": \"" + message + "\"}");
        }

        freeReplyObject(reply);
        spdlog::info("No messages in queue");
        return crow::response(404, "{\"message\": \"No messages in queue\"}");
    });


    // Configure and run the server
    app.port(18080)
       .multithreaded()
       .run();

    return 0;
}
            </code></pre>
        </div>
    </div>

    <div class="file-block">
        <div class="file-header"><code>Dockerfile</code></div>
        <div class="file-content">
            <p>The <code>Dockerfile</code> now includes the installation of the <code>hiredis</code>, <code>sqlite3</code>, <code>spdlog</code>, <code>jwt-cpp</code>, and <code>libsodium</code> libraries.</p>
            <pre><code class="language-dockerfile">
# Dockerfile

# ---- Stage 1: The Builder ----
FROM gcc:latest AS builder

WORKDIR /app

# Install dependencies, including the hiredis, sqlite3, spdlog, jwt-cpp, and libsodium client
RUN apt-get update && apt-get install -y cmake git libasio-dev libboost-system-dev libhiredis-dev libsqlite3-dev libssl-dev libsodium-dev

RUN git clone https://github.com/CrowCpp/Crow.git
RUN git clone https://github.com/gabime/spdlog.git
RUN git clone https://github.com/Thalhammer/jwt-cpp.git

COPY src/main.cpp .

# Compile the application, linking against hiredis, sqlite3, ssl, crypto, and sodium
RUN g++ -I Crow/include -I spdlog/include -I jwt-cpp/include -o api main.cpp -lpthread -lboost_system -static-libstdc++ -lhiredis -lsqlite3 -lssl -lcrypto -lsodium

# ---- Stage 2: The Final Image ----
FROM debian:stable-slim AS final

WORKDIR /app

# Install runtime dependencies
RUN apt-get update && apt-get install -y libboost-system-dev libhiredis0.14 libsqlite3-0 libssl-dev libsodium23 && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/api .

EXPOSE 18080

CMD ["./api"]
            </code></pre>
        </div>
    </div>

    <div class="file-block">
        <div class="file-header"><code>docker-compose.yml</code></div>
        <div class="file-content">
            <p>The <code>docker-compose.yml</code> file now defines the C++ application and Redis services, with volumes for the SQLite database and logs, and a JWT secret.</p>
            <pre><code class="language-yaml">
# docker-compose.yml

services:
  cpp-api:
    container_name: my_cpp_api
    build: .
    ports:
      - "8081:18080"
    restart: unless-stopped
    depends_on:
      - redis
    environment:
      - REDIS_HOST=redis
      - JWT_SECRET=your-super-secret-key
    volumes:
      - ./database:/app/database
      - ./logs:/app/logs

  redis:
    image: "redis:alpine"
    container_name: my_redis
    ports:
      - "6380:6379"
    restart: unless-stopped
            </code></pre>
        </div>
    </div>

    <h2>4. Building and Running the Application</h2>
    <p>With all the files in place, open your terminal in the project's root directory and run the following command:</p>
    <pre><code>docker-compose up --build</code></pre>
    <p>Docker will now build the images and start the C++ API and Redis containers. The API is available at <code>http://localhost:8081</code>.</p>

    <h2>5. API Endpoints Guide</h2>
    <p>Here are the available endpoints and how to use them with <code>curl</code>.</p>

    <h3>Authentication</h3>
    <ul>
        <li>
            <strong>Register a new user</strong><br>
            <code>POST /register</code><br>
            <pre><code>curl -X POST -H "Content-Type: application/json" -d '{"name":"John Doe","email":"john.doe@example.com","password":"your-password"}' http://localhost:8081/register</code></pre>
        </li>
        <li>
            <strong>Login as an existing user</strong><br>
            <code>POST /login</code><br>
            <pre><code>curl -X POST -H "Content-Type: application/json" -d '{"email":"john.doe@example.com","password":"your-password"}' http://localhost:8081/login</code></pre>
        </li>
    </ul>

    <h3>Users (Protected)</h3>
    <ul>
        <li>
            <strong>Get all users</strong><br>
            <code>GET /users</code><br>
            <pre><code>curl -H "Authorization: Bearer &lt;your-jwt&gt;" http://localhost:8081/users</code></pre>
        </li>
        <li>
            <strong>Get a specific user</strong><br>
            <code>GET /users/&lt;id&gt;</code><br>
            <pre><code>curl -H "Authorization: Bearer &lt;your-jwt&gt;" http://localhost:8081/users/1</code></pre>
        </li>
        <li>
            <strong>Update a user</strong><br>
            <code>PUT /users/&lt;id&gt;</code><br>
            <pre><code>curl -X PUT -H "Content-Type: application/json" -H "Authorization: Bearer &lt;your-jwt&gt;" -d '{"name":"Jane Doe"}' http://localhost:8081/users/1</code></pre>
        </li>
        <li>
            <strong>Delete a user</strong><br>
            <code>DELETE /users/&lt;id&gt;</code><br>
            <pre><code>curl -X DELETE -H "Authorization: Bearer &lt;your-jwt&gt;" http://localhost:8081/users/1</code></pre>
        </li>
    </ul>

    <h3>Message Queue</h3>
    <ul>
        <li>
            <strong>Queue a message</strong><br>
            <code>POST /messages</code><br>
            <pre><code>curl -X POST -H "Content-Type: application/json" -d '{"message":"hello world"}' http://localhost:8081/messages</code></pre>
        </li>
        <li>
            <strong>Retrieve a message</strong><br>
            <code>GET /messages</code><br>
            <pre><code>curl http://localhost:8081/messages</code></pre>
        </li>
    </ul>

</body>
</html>